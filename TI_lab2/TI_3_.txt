p q вводим с клавы

Длинную арифметику (нужен вероят тест простоты) делать не обязательно 

Если корот то тетст на простоту


Подобрать откр и закр ключи (ввести с клавы закрытый)

x1*a + y1*b = нод(a, b)
Небольшие числа

На листике показать как работает

Формула шифрования: возвлдим в степень ... открытого ключа

Если без длинной арифметике получаем 16 бит
Ограничение блока: 0<= mi <= r - 1, знать почему не расшифрует при др знач.
Знать, как разбить на блоки

Должна быть переменная которая с 1 накапливает степень

Файлы с любым расширением

Вводим закрытый, прогп ищет открытый

Алгоритм эльгамаль
Найти все первообразные доя данного ключа и ввывести доя выбора
Поользователь выбирает сам для шифрования
Результат два числа

Открытый ключ - (y, g, k) 
Закрытый (x, p) 
Фла mi = ba^-x  mod p

Рабина
 P = q = 3 mod 4, p≈q
N = pg
B < n
Ci = mi(mi + b) mod n

Mi^2 + bmi - ci = 0 mod n
D = b^2 + 4c
X =( - b + ¬/D) /2
Из расшир эвклида наход yp yq
Yp*p + yq*q = 1
4 корня из дискриминанта

D1 = yp*p*mq + yq*q * mp

В выходной файл записываем байты









	RSA:
p и q должны вводиться с клавиатуры
Вероятностный тест простоты (Тест Ферма)
(для тестов) берём маленькие числа
знать все формулы
уметь использовать их
тождества
шифруем с 8 бит в 16 бит (при длинной шифровке)
причины, почему не расшифрует(подробно)
знать разбиение на блоки и что зависит от модуля
написание работы алгоритма возведения в степень
если степень нечётная, то от степени отнимается единица и умножается на 2
если чётная, то основание возводится в квадрат и стпень делится на 2
описание шагов
знать функцию Эйлера
расширенный Алгоритм Евклида
требования, предъявляемые к размеру шифруемого блока

/*
Для защиты должны быть 3 алгоритма
Программа должна шифровать файлы с любым расширением
(Для длинной арифметики тесты с длинными p и q, а также тест простоты)
результат работы программы преобразуем в числа
а файл записываем байты
*/
	
	Алгоритм Криптосистемы Эль-Гамаля:
(длинная арифметика) Вероятностный тест простоты
Как понять что g первообразная?
1) g ^ (f(p)) = 1 mod(p)
2) g ^ (e) * mod(p) != 1

1 <= e <= p - 1
Алгоритм для уменьшения числа итераций и нахождения числа g
(берём p и раскладываем на взаимнопростые числа, берём g ... p mod != 1)

/*
Программа должна давать пользователю возмонжность выбирать первообразную
Готовиться к вычислению первообразной на бумажке
Чтобы на экране было видно 2 числа (a и b) и как они меняются
*/

Открытый ключ и закрытый ключ:
(y,g,k)
(x,p)

m(i) = b * a^(-x) * mod(p)

(Для возведения в степень используем формулу возведения в степень)

	Алгоритм Криптосистем Рабина:
(однозначная расшифровка и запись любых форматов)
1)
Открытый и закрытый ключ:
p (три палочки) q (три палочки) 3 * mod4
p ~~ q
2)
n = p * q
3)
b < m
4)
C(i) = m(i) (m(i) + b)  * mod(n)
m(i)^2 + b * m(i) - C(i) = 0(O?) mod(n)
D = b^2 + 4c
(Используем расширенный алгоритм Евклида)
x = 1/2 * (-b + D^(1/2))
m(p) = D^(1/2) = D^((p+1)/4) mod(p)
m(q) = D^(1/2) = D^((q+1)/4) mod(q)
y(p) * p + y(q) * q = 1
D(1) = y(p) * p * m(q) + y(q) * q * m(p) (mod(n))
D(2) = D(1) - n
D(3) = y(p) * p * m(q) - y(q) * q * m(p) (mod(n))
D(4) = D(3) - n
/*
Программа должна выбирать правильный x и записывать
Взависимости от n добивать размер, чтобы для правильной расшифровки высчитать кол-во байт
В выходной файл записываем байты, а на экран - числа
*/
